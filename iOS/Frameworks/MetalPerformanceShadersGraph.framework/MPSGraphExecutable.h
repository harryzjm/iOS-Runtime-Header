//
//     Generated by classdump-c 4.2.0 (64 bit).
//
//  Copyright (C) 1997-2019 Steve Nygard. Updated in 2022 by Kevin Bradley.
//

#import <objc/NSObject.h>

@class MPSGraph, NSArray, NSDictionary, NSFileManager, NSString;

@interface MPSGraphExecutable : NSObject
{
    MPSGraph *_graph;
    struct shared_ptr<mlir::MLIRContext> _executableContext;
    void *_builder;
    struct OwningModuleRef _originalModule;
    void *_symbolTable;
    unsigned long long _compilerOptions;
    struct unordered_map<std::string, std::unique_ptr<GPURuntime>, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, std::unique_ptr<GPURuntime>>>> _runtimeCache;
    struct unordered_map<std::string, std::unique_ptr<BaseRuntime>, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, std::unique_ptr<BaseRuntime>>>> _newRuntimeCache;
    struct unordered_map<std::string, mlir::OwningModuleRef, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, mlir::OwningModuleRef>>> _optimizedModuleCache;
    struct unordered_map<std::string, mlir::OwningModuleRef, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, mlir::OwningModuleRef>>> _optimizedNoDeviceModuleCache;
    struct _opaque_pthread_mutex_t _executableMutex;
    NSArray *_targetTensorArray;
    NSArray *_targetOperations;
    NSArray *_feedTensorArray;
    NSDictionary *_feeds;
    unsigned long long _modelUID;
    unsigned long long _compilationID;
    unsigned long long _evDumpModuleFlag;
    NSString *_evDumpModulePath;
    NSString *_modelFileArchivePath;
    NSFileManager *_fileManager;
    _Bool _useScratchPadContext;
    _Bool _useLegacyRuntime;
    _Bool _enableCommitAndContinue;
    _Bool _forceANERuntimeHack;
    unsigned long long _options;
}

- (id).cxx_construct;
- (void).cxx_destruct;
@property unsigned long long options; // @synthesize options=_options;
@property(readonly) NSArray *feedTensors; // @synthesize feedTensors=_feedTensorArray;
@property(readonly) NSArray *targetTensors; // @synthesize targetTensors=_targetTensorArray;
- (id)runInternalWithDevice:(id)arg1 commandBuffer:(id)arg2 feeds:(id)arg3 results:(id)arg4 executionDescriptor:(id)arg5 executableExecutionDescriptor:(id)arg6 mpsGraphOwnedCommandBuffer:(_Bool)arg7;
- (id)runInternalWithDevice:(id)arg1 commandBuffer:(id)arg2 feedsDictionary:(id)arg3 resultsDictionary:(id)arg4 executionDescriptor:(id)arg5 executableExecutionDescriptor:(id)arg6 mpsGraphOwnedCommandBuffer:(_Bool)arg7;
- (id)allocateTensorDataTargetsForDevice:(id)arg1 inputsArray:(id)arg2;
- (void *)getNewRuntimeForDevice:(id)arg1 module:(struct ModuleOp)arg2;
- (void)encodeInternalWithMPSCommandBuffer:(id)arg1 inputsArray:(id)arg2 resultsArray:(id)arg3 executionDescriptor:(id)arg4 executableExecutionDescriptor:(id)arg5;
- (id)encodeWithMPSCommandBuffer:(id)arg1 inputsArray:(id)arg2 resultsArray:(id)arg3 executionDescriptor:(id)arg4;
- (id)encodeToCommandBuffer:(id)arg1 inputsArray:(id)arg2 resultsArray:(id)arg3 executionDescriptor:(id)arg4;
- (id)runAsyncWithCommandQueue:(id)arg1 inputsArray:(id)arg2 resultsArray:(id)arg3 executionDescriptor:(id)arg4;
- (id)runAsyncWithMTLCommandQueue:(id)arg1 inputsArray:(id)arg2 resultsArray:(id)arg3 executionDescriptor:(id)arg4;
- (id)runWithMTLCommandQueue:(id)arg1 inputsArray:(id)arg2 resultsArray:(id)arg3 executionDescriptor:(id)arg4;
- (id)runAsyncWithDevice:(id)arg1 inputsArray:(id)arg2 resultsArray:(id)arg3 executionDescriptor:(id)arg4;
- (id)runWithDevice:(id)arg1 inputsArray:(id)arg2 resultsArray:(id)arg3 executionDescriptor:(id)arg4;
- (id)runWithMTLCommandQueue:(id)arg1 inputsArray:(id)arg2 resultsArray:(id)arg3;
- (id)getTensorDataArraysWithDevice:(id)arg1 feedsDictionary:(id)arg2 resultsDictionary:(id)arg3 inputsArray:(id)arg4 resultsArray:(id)arg5 newRuntime:(_Bool)arg6;
- (id)getTargetShapesForDevice:(id)arg1 inputsArray:(id)arg2;
- (id)allocateTargetsForDevice:(id)arg1 inputsArray:(id)arg2;
- (void *)getRuntimeForDevice:(id)arg1 module:(struct ModuleOp)arg2;
- (id)getOutputShapes;
- (id)getInputShapes;
- (id)debugDescription;
- (id)getIR;
- (void)dump;
- (void)dealloc;
- (struct OwningModuleRef)optimizationPassesWithDevice:(id)arg1 sourceModule:(void *)arg2 fileToStoreName:(id)arg3;
- (struct ModuleOp)specializeWithDevice:(id)arg1 inputsArray:(id)arg2 compilationDescriptor:(id)arg3;
- (void)specializeWithDevice:(id)arg1 inputShapes:(id)arg2 compilationDescriptor:(id)arg3;
- (void)specializeWithDevice:(id)arg1 inputTypes:(id)arg2 compilationDescriptor:(id)arg3;
- (struct ModuleOp)specializedModuleWithDevice:(id)arg1 inputShapes:(id)arg2 compilationDescriptor:(id)arg3;
- (void)fileBackModule:(void *)arg1 withPath:(id)arg2;
- (struct ModuleOp)cloneForFeeds:(id)arg1 targetTensors:(id)arg2 targetOperations:(id)arg3;
- (id)getOperationsToVisitForOperation:(id)arg1 visitedOperations:(id)arg2;
- (void)recurseFeeds:(id)arg1 targetTensors:(id)arg2 targetOperations:(id)arg3;
- (void)recurseOperation:(id)arg1 operationsRecursed:(id)arg2 tensorToValueMap:(void *)arg3;
- (_Bool)isExecutableForFeeds:(id)arg1 targetTensors:(id)arg2 targetOperations:(id)arg3;
- (void)sanitizeExternalModuleWithVariableFetchHandler:(CDUnknownBlockType)arg1;
- (id)initWithMLIRSource:(id)arg1 executableDescriptor:(id)arg2;
- (id)initWithMLIRSourceFromURL:(id)arg1 executableDescriptor:(id)arg2;
- (id)initWithMILProgram:(void *)arg1 executableDescriptor:(id)arg2;
- (id)initializeWithMLIRModule:(struct ModuleOp)arg1 executableDescriptor:(id)arg2;
- (id)initWithMLIRModule:(struct ModuleOp)arg1 executableDescriptor:(id)arg2;
- (id)initWithGraph:(id)arg1 feeds:(id)arg2 targetTensors:(id)arg3 targetOperations:(id)arg4 executableDescriptor:(id)arg5;
- (void)commonPostInit:(struct ModuleOp)arg1;
- (void)commonPreInit;
- (void)initializeMLIR;

@end

