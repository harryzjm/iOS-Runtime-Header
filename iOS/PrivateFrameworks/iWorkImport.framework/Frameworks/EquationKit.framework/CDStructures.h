//
//     Generated by classdump-c 4.2.0 (64 bit).
//
//  Copyright (C) 1997-2019 Steve Nygard. Updated in 2022 by Kevin Bradley.
//

#pragma mark Named Structures

struct CGAffineTransform {
    double _field1;
    double _field2;
    double _field3;
    double _field4;
    double _field5;
    double _field6;
};

struct CGPoint {
    double x;
    double y;
};

struct CGRect {
    struct CGPoint origin;
    struct CGSize size;
};

struct CGSize {
    double width;
    double height;
};

struct Config {
    int _field1;
    _Bool _field2;
    _Bool _field3;
    _Bool _field4;
    _Bool _field5;
};

struct EQKitCacheLRUCounter {
    unsigned long long _field1;
};

struct Manager {
    CDUnknownFunctionPointerType *_field1;
    struct STIXCollection *_field2;
    struct EQKitCacheLRUCounter _field3;
};

struct STIXCollection;

struct Schemata {
    CDUnknownFunctionPointerType *_field1;
    int _field2;
    id _field3;
    id _field4;
};

struct __wrap_iter<double *> {
    double *_field1;
};

struct _xmlDoc {
    void *_field1;
    int _field2;
    char *_field3;
    struct _xmlNode *_field4;
    struct _xmlNode *_field5;
    struct _xmlNode *_field6;
    struct _xmlNode *_field7;
    struct _xmlNode *_field8;
    struct _xmlDoc *_field9;
    int _field10;
    int _field11;
    struct _xmlDtd *_field12;
    struct _xmlDtd *_field13;
    struct _xmlNs *_field14;
    char *_field15;
    char *_field16;
    void *_field17;
    void *_field18;
    char *_field19;
    int _field20;
    struct _xmlDict *_field21;
    void *_field22;
    int _field23;
    int _field24;
};

struct _xmlDtd;

struct _xmlNode {
    void *_field1;
    int _field2;
    char *_field3;
    struct _xmlNode *_field4;
    struct _xmlNode *_field5;
    struct _xmlNode *_field6;
    struct _xmlNode *_field7;
    struct _xmlNode *_field8;
    struct _xmlDoc *_field9;
    struct _xmlNs *_field10;
    char *_field11;
    struct _xmlAttr *_field12;
    struct _xmlNs *_field13;
    void *_field14;
    unsigned short _field15;
    unsigned short _field16;
};

struct _xmlNs {
    struct _xmlNs *_field1;
    int _field2;
    char *_field3;
    char *_field4;
    void *_field5;
    struct _xmlDoc *_field6;
};

struct deque<EQKitMathMLParserState, std::allocator<EQKitMathMLParserState>> {
    struct __split_buffer<EQKitMathMLParserState *, std::allocator<EQKitMathMLParserState *>> {
        int **__first_;
        int **__begin_;
        int **__end_;
        struct __compressed_pair<EQKitMathMLParserState **, std::allocator<EQKitMathMLParserState *>> {
            int **__value_;
        } __end_cap_;
    } __map_;
    unsigned long long __start_;
    struct __compressed_pair<unsigned long, std::allocator<EQKitMathMLParserState>> {
        unsigned long long __value_;
    } __size_;
};

struct stack<EQKitMathMLParserState, std::deque<EQKitMathMLParserState>> {
    struct deque<EQKitMathMLParserState, std::allocator<EQKitMathMLParserState>> c;
};

struct vector<EQKitTypes::Crossout::Enum, std::allocator<EQKitTypes::Crossout::Enum>> {
    int *__begin_;
    int *__end_;
    struct __compressed_pair<EQKitTypes::Crossout::Enum *, std::allocator<EQKitTypes::Crossout::Enum>> {
        int *__value_;
    } __end_cap_;
};

#pragma mark Typedef'd Structures

// Template types
typedef struct __wrap_iter<double *> {
    double *_field1;
} __wrap_iter_8fb6ff7c;

